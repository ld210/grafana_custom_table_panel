{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///./transformers.ts","webpack:///external \"app/core/utils/flatten\"","webpack:///external \"app/core/time_series2\"","webpack:///external \"app/core/table_model\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","e","__WEBPACK_EXTERNAL_MODULE__0__","mergeTablesIntoModel","u","a","transformers","areRowsMatching","columns","row","otherRow","foundFieldToMatch","columnIndex","length","dst","tables","_i","arguments","model","_table_model2","slice","rows","columnNames","columnsUnion","reduce","acc","series","forEach","col","text","push","columnIndexMapper","map","flattenedRows","seriesIndex","mapper","alteredRow","to","from","mergedRows","compactedRows","rowIndex","offset","match","_lodash2","findIndex","matchedRow","timeseries_to_rows","description","getColumns","transform","data","panel","type","y","datapoints","dp","target","timeseries_to_columns","points","timeKey","toString","time","point","values","timeseries_aggregations","_time_series2","alias","getFlotPairs","cells","stats","annotations","evt","title","tags","table","noTableIndex","message","String","fromCharCode","apply","concat","json","names","maxDocs","Math","min","doc","flattened","_flatten2","propName","z","_a","tableCol","filterable","isObject","JSON","stringify","transformDataToTable","transformer","__WEBPACK_EXTERNAL_MODULE__6__","__WEBPACK_EXTERNAL_MODULE__7__","__WEBPACK_EXTERNAL_MODULE__8__"],"mappings":"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","file":"transformer.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import _ from 'lodash';\nimport flatten from 'grafana/app/core/utils/flatten';\nimport TimeSeries from 'grafana/app/core/time_series2';\nimport TableModel from 'grafana/app/core/table_model';\n\nconst transformers = {};\n\n// Returns true if both rows have matching non-empty fields as well as matching\n// indexes where one field is empty and the other is not\nfunction areRowsMatching(columns, row, otherRow) {\n  let foundFieldToMatch = false;\n  for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n    if (row[columnIndex] !== undefined && otherRow[columnIndex] !== undefined) {\n      if (row[columnIndex] !== otherRow[columnIndex]) {\n        return false;\n      }\n    } else if (row[columnIndex] === undefined || otherRow[columnIndex] === undefined) {\n      foundFieldToMatch = true;\n    }\n  }\n  return foundFieldToMatch;\n}\n\nexport function mergeTablesIntoModel(dst?: TableModel, ...tables: TableModel[]): TableModel {\n  const model = dst || new TableModel();\n\n  if (arguments.length === 1) {\n    return model;\n  }\n  // Single query returns data columns and rows as is\n  if (arguments.length === 2) {\n    model.columns = tables[0].hasOwnProperty('columns') ? [...tables[0].columns] : [];\n    model.rows = tables[0].hasOwnProperty('rows') ? [...tables[0].rows] : [];\n    return model;\n  }\n\n  // Track column indexes of union: name -> index\n  const columnNames = {};\n\n  // Union of all non-value columns\n  const columnsUnion = tables.slice().reduce((acc, series) => {\n    series.columns.forEach((col: any) => {\n      const { text } = col;\n      if (columnNames[text] === undefined) {\n        columnNames[text] = acc.length;\n        acc.push(col);\n      }\n    });\n    return acc;\n  }, [] as any[]);\n\n  // Map old column index to union index per series, e.g.,\n  // given columnNames {A: 0, B: 1} and\n  // data [{columns: [{ text: 'A' }]}, {columns: [{ text: 'B' }]}] => [[0], [1]]\n  const columnIndexMapper = tables.map(series => series.columns.map(col => columnNames[col.text]));\n\n  // Flatten rows of all series and adjust new column indexes\n  const flattenedRows = tables.reduce((acc, series, seriesIndex) => {\n    const mapper = columnIndexMapper[seriesIndex];\n    series.rows.forEach(row => {\n      const alteredRow: any[] = [];\n      // Shifting entries according to index mapper\n      mapper.forEach((to, from) => {\n        alteredRow[to] = row[from];\n      });\n      acc.push(alteredRow);\n    });\n    return acc;\n  }, [] as any[]);\n\n  // Merge rows that have same values for columns\n  const mergedRows = {};\n  const compactedRows = flattenedRows.reduce((acc, row, rowIndex) => {\n    if (!mergedRows[rowIndex]) {\n      // Look from current row onwards\n      let offset = rowIndex + 1;\n      // More than one row can be merged into current row\n      while (offset < flattenedRows.length) {\n        // Find next row that could be merged\n        const match = _.findIndex(flattenedRows, otherRow => areRowsMatching(columnsUnion, row, otherRow), offset);\n        if (match > -1) {\n          const matchedRow = flattenedRows[match];\n          // Merge values from match into current row if there is a gap in the current row\n          for (let columnIndex = 0; columnIndex < columnsUnion.length; columnIndex++) {\n            if (row[columnIndex] === undefined && matchedRow[columnIndex] !== undefined) {\n              row[columnIndex] = matchedRow[columnIndex];\n            }\n          }\n          // Don't visit this row again\n          mergedRows[match] = matchedRow;\n          // Keep looking for more rows to merge\n          offset = match + 1;\n        } else {\n          // No match found, stop looking\n          break;\n        }\n      }\n      acc.push(row);\n    }\n    return acc;\n  }, []);\n\n  model.columns = columnsUnion;\n  model.rows = compactedRows;\n  return model;\n}\n\ntransformers['timeseries_to_rows'] = {\n  description: 'Time series to rows',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns = [{ text: 'Time', type: 'date' }, { text: 'Metric' }, { text: 'Value' }];\n\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        model.rows.push([dp[1], series.target, dp[0]]);\n      }\n    }\n  },\n};\n\ntransformers['timeseries_to_columns'] = {\n  description: 'Time series to columns',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({ text: 'Time', type: 'date' });\n\n    // group by time\n    const points = {};\n\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      model.columns.push({ text: series.target });\n\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const timeKey = dp[1].toString();\n\n        if (!points[timeKey]) {\n          points[timeKey] = { time: dp[1] };\n          points[timeKey][i] = dp[0];\n        } else {\n          points[timeKey][i] = dp[0];\n        }\n      }\n    }\n\n    for (const time in points) {\n      const point = points[time];\n      const values = [point.time];\n\n      for (let i = 0; i < data.length; i++) {\n        const value = point[i];\n        values.push(value);\n      }\n\n      model.rows.push(values);\n    }\n  },\n};\n\ntransformers['timeseries_aggregations'] = {\n  description: 'Time series aggregations',\n  getColumns: () => {\n    return [\n      { text: 'Avg', value: 'avg' },\n      { text: 'Min', value: 'min' },\n      { text: 'Max', value: 'max' },\n      { text: 'Total', value: 'total' },\n      { text: 'Current', value: 'current' },\n      { text: 'Count', value: 'count' },\n    ];\n  },\n  transform: (data, panel, model) => {\n    let i, y;\n    model.columns.push({ text: 'Metric' });\n\n    for (i = 0; i < panel.columns.length; i++) {\n      model.columns.push({ text: panel.columns[i].text });\n    }\n\n    for (i = 0; i < data.length; i++) {\n      const series = new TimeSeries({\n        datapoints: data[i].datapoints,\n        alias: data[i].target,\n      });\n\n      series.getFlotPairs('connected');\n      const cells = [series.alias];\n\n      for (y = 0; y < panel.columns.length; y++) {\n        cells.push(series.stats[panel.columns[y].value]);\n      }\n\n      model.rows.push(cells);\n    }\n  },\n};\n\ntransformers['annotations'] = {\n  description: 'Annotations',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({ text: 'Time', type: 'date' });\n    model.columns.push({ text: 'Title' });\n    model.columns.push({ text: 'Text' });\n    model.columns.push({ text: 'Tags' });\n\n    if (!data || !data.annotations || data.annotations.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < data.annotations.length; i++) {\n      const evt = data.annotations[i];\n      model.rows.push([evt.time, evt.title, evt.text, evt.tags]);\n    }\n  },\n};\n\ntransformers['table'] = {\n  description: 'Table',\n  getColumns: data => {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Single query returns data columns as is\n    if (data.length === 1) {\n      return [...data[0].columns];\n    }\n\n    // Track column indexes: name -> index\n    const columnNames = {};\n\n    // Union of all columns\n    const columns = data.reduce((acc, series) => {\n      series.columns.forEach(col => {\n        const { text } = col;\n        if (columnNames[text] === undefined) {\n          columnNames[text] = acc.length;\n          acc.push(col);\n        }\n      });\n      return acc;\n    }, []);\n\n    return columns;\n  },\n  transform: (data, panel, model) => {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    const noTableIndex = _.findIndex(data, (d: any) => d.type !== 'table');\n    if (noTableIndex > -1) {\n      throw {\n        message: `Result of query #${String.fromCharCode(\n          65 + noTableIndex\n        )} is not in table format, try using another transform.`,\n      };\n    }\n\n    mergeTablesIntoModel(model, ...data);\n  },\n};\n\ntransformers['json'] = {\n  description: 'JSON Data',\n  getColumns: data => {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    const names: any = {};\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      if (series.type !== 'docs') {\n        continue;\n      }\n\n      // only look at 100 docs\n      const maxDocs = Math.min(series.datapoints.length, 100);\n      for (let y = 0; y < maxDocs; y++) {\n        const doc = series.datapoints[y];\n        const flattened = flatten(doc, null);\n        for (const propName in flattened) {\n          names[propName] = true;\n        }\n      }\n    }\n\n    return _.map(names, (value, key) => {\n      return { text: key, value: key };\n    });\n  },\n  transform: (data, panel, model) => {\n    let i, y, z;\n\n    for (const column of panel.columns) {\n      const tableCol: any = { text: column.text };\n\n      // if filterable data then set columns to filterable\n      if (data.length > 0 && data[0].filterable) {\n        tableCol.filterable = true;\n      }\n\n      model.columns.push(tableCol);\n    }\n\n    if (model.columns.length === 0) {\n      model.columns.push({ text: 'JSON' });\n    }\n\n    for (i = 0; i < data.length; i++) {\n      const series = data[i];\n\n      for (y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const values: any[] = [];\n\n        if (_.isObject(dp) && panel.columns.length > 0) {\n          const flattened = flatten(dp, null);\n          for (z = 0; z < panel.columns.length; z++) {\n            values.push(flattened[panel.columns[z].value]);\n          }\n        } else {\n          values.push(JSON.stringify(dp));\n        }\n\n        model.rows.push(values);\n      }\n    }\n  },\n};\n\nfunction transformDataToTable(data, panel) {\n  const model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  const transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw { message: 'Transformer ' + panel.transform + ' not found' };\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport { transformers, transformDataToTable };\n","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;"],"sourceRoot":""}