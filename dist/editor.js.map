{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///./editor.ts","webpack:///./transformers.ts","webpack:///external \"app/core/utils/flatten\"","webpack:///external \"app/core/time_series2\"","webpack:///external \"app/core/table_model\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","0","e","__WEBPACK_EXTERNAL_MODULE__0__","TablePanelEditorCtrl","undefined","$scope","$q","uiSegmentSrv","this","editor","panelCtrl","ctrl","panel","transformers","_transformers","fontSizes","addColumnSegment","newPlusButton","$inject","updateTransformHints","canSetColumns","columnsHelpMessage","transform","getColumnOptions","_this","dataRaw","columns","getColumns","segments","_lodash2","map","newSegment","text","console","log","column","find","push","plusButton","html","render","removeColumn","without","restrict","scope","templateUrl","controller","a","4","transformDataToTable","mergeTablesIntoModel","_interopRequireDefault","_flatten2","_time_series2","obj","foundFieldToMatch","columnIndex","length","row","otherRow","f","arguments","model","dst","_table_model2","tables","slice","rows","columnNames","columnsUnion","reduce","acc","series","forEach","col","columnIndexMapper","flattenedRows","seriesIndex","mapper","alteredRow","to","from","mergedRows","compactedRows","rowIndex","offset","match","findIndex","matchedRow","timeseries_to_rows","description","data","type","y","datapoints","dp","target","timeseries_to_columns","points","u","timeKey","toString","time","values","point","timeseries_aggregations","alias","cells","annotations","evt","title","tags","table","noTableIndex","message","String","fromCharCode","apply","concat","json","names","maxDocs","Math","min","flattened","doc","propName","z","_i","_a","tableCol","filterable","transformer"],"mappings":"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","file":"editor.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import _ from 'lodash';\nimport { transformers } from './transformers';\n\nexport class TablePanelEditorCtrl {\n  panel: any;\n  panelCtrl: any;\n  transformers: any;\n  fontSizes: any;\n  addColumnSegment: any;\n  getColumnNames: any;\n  canSetColumns: boolean;\n  columnsHelpMessage: string;\n\n  /** @ngInject */\n  constructor($scope, private $q, private uiSegmentSrv) {\n    $scope.editor = this;\n    this.panelCtrl = $scope.ctrl;\n    this.panel = this.panelCtrl.panel;\n    this.transformers = transformers;\n    this.fontSizes = ['80%', '90%', '100%', '110%', '120%', '130%', '150%', '160%', '180%', '200%', '220%', '250%'];\n    this.addColumnSegment = uiSegmentSrv.newPlusButton();\n    this.updateTransformHints();\n  }\n\n  updateTransformHints() {\n    this.canSetColumns = false;\n    this.columnsHelpMessage = '';\n\n    switch (this.panel.transform) {\n      case 'timeseries_aggregations': {\n        this.canSetColumns = true;\n        break;\n      }\n      case 'json': {\n        this.canSetColumns = true;\n        break;\n      }\n      case 'table': {\n        this.columnsHelpMessage = 'Columns and their order are determined by the data query';\n      }\n    }\n  }\n\n  getColumnOptions() {\n    if (!this.panelCtrl.dataRaw) {\n      return this.$q.when([]);\n    }\n    const columns = this.transformers[this.panel.transform].getColumns(this.panelCtrl.dataRaw);\n    const segments = _.map(columns, (c: any) => this.uiSegmentSrv.newSegment({ value: c.text }));\n    console.log('get column options: ', {segments});\n    return this.$q.when(segments);\n  }\n\n  addColumn() {\n    const columns = transformers[this.panel.transform].getColumns(this.panelCtrl.dataRaw);\n    console.log('addColumn: ', {columns});\n    const column = _.find(columns, { text: this.addColumnSegment.value });\n\n    if (column) {\n      this.panel.columns.push(column);\n      this.render();\n    }\n\n    const plusButton = this.uiSegmentSrv.newPlusButton();\n    this.addColumnSegment.html = plusButton.html;\n    this.addColumnSegment.value = plusButton.value;\n  }\n\n  transformChanged() {\n    this.panel.columns = [];\n    if (this.panel.transform === 'timeseries_aggregations') {\n      this.panel.columns.push({ text: 'Avg', value: 'avg' });\n    }\n\n    this.updateTransformHints();\n    this.render();\n  }\n\n  render() {\n    this.panelCtrl.render();\n  }\n\n  removeColumn(column) {\n    this.panel.columns = _.without(this.panel.columns, column);\n    this.panelCtrl.render();\n  }\n}\n\n/** @ngInject */\nexport function tablePanelEditor($q, uiSegmentSrv) {\n  'use strict';\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: 'public/plugins/tradelab-bidder-table/editor.html',\n    controller: TablePanelEditorCtrl,\n  };\n}\n","import _ from 'lodash';\nimport flatten from 'grafana/app/core/utils/flatten';\nimport TimeSeries from 'grafana/app/core/time_series2';\nimport TableModel from 'grafana/app/core/table_model';\n\nconst transformers = {};\n\n// Returns true if both rows have matching non-empty fields as well as matching\n// indexes where one field is empty and the other is not\nfunction areRowsMatching(columns, row, otherRow) {\n  let foundFieldToMatch = false;\n  for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n    if (row[columnIndex] !== undefined && otherRow[columnIndex] !== undefined) {\n      if (row[columnIndex] !== otherRow[columnIndex]) {\n        return false;\n      }\n    } else if (row[columnIndex] === undefined || otherRow[columnIndex] === undefined) {\n      foundFieldToMatch = true;\n    }\n  }\n  return foundFieldToMatch;\n}\n\nexport function mergeTablesIntoModel(dst?: TableModel, ...tables: TableModel[]): TableModel {\n  const model = dst || new TableModel();\n\n  if (arguments.length === 1) {\n    return model;\n  }\n  // Single query returns data columns and rows as is\n  if (arguments.length === 2) {\n    model.columns = tables[0].hasOwnProperty('columns') ? [...tables[0].columns] : [];\n    model.rows = tables[0].hasOwnProperty('rows') ? [...tables[0].rows] : [];\n    return model;\n  }\n\n  // Track column indexes of union: name -> index\n  const columnNames = {};\n\n  // Union of all non-value columns\n  const columnsUnion = tables.slice().reduce((acc, series) => {\n    series.columns.forEach((col: any) => {\n      const { text } = col;\n      if (columnNames[text] === undefined) {\n        columnNames[text] = acc.length;\n        acc.push(col);\n      }\n    });\n    return acc;\n  }, [] as any[]);\n\n  // Map old column index to union index per series, e.g.,\n  // given columnNames {A: 0, B: 1} and\n  // data [{columns: [{ text: 'A' }]}, {columns: [{ text: 'B' }]}] => [[0], [1]]\n  const columnIndexMapper = tables.map(series => series.columns.map(col => columnNames[col.text]));\n\n  // Flatten rows of all series and adjust new column indexes\n  const flattenedRows = tables.reduce((acc, series, seriesIndex) => {\n    const mapper = columnIndexMapper[seriesIndex];\n    series.rows.forEach(row => {\n      const alteredRow: any[] = [];\n      // Shifting entries according to index mapper\n      mapper.forEach((to, from) => {\n        alteredRow[to] = row[from];\n      });\n      acc.push(alteredRow);\n    });\n    return acc;\n  }, [] as any[]);\n\n  // Merge rows that have same values for columns\n  const mergedRows = {};\n  const compactedRows = flattenedRows.reduce((acc, row, rowIndex) => {\n    if (!mergedRows[rowIndex]) {\n      // Look from current row onwards\n      let offset = rowIndex + 1;\n      // More than one row can be merged into current row\n      while (offset < flattenedRows.length) {\n        // Find next row that could be merged\n        const match = _.findIndex(flattenedRows, otherRow => areRowsMatching(columnsUnion, row, otherRow), offset);\n        if (match > -1) {\n          const matchedRow = flattenedRows[match];\n          // Merge values from match into current row if there is a gap in the current row\n          for (let columnIndex = 0; columnIndex < columnsUnion.length; columnIndex++) {\n            if (row[columnIndex] === undefined && matchedRow[columnIndex] !== undefined) {\n              row[columnIndex] = matchedRow[columnIndex];\n            }\n          }\n          // Don't visit this row again\n          mergedRows[match] = matchedRow;\n          // Keep looking for more rows to merge\n          offset = match + 1;\n        } else {\n          // No match found, stop looking\n          break;\n        }\n      }\n      acc.push(row);\n    }\n    return acc;\n  }, []);\n\n  model.columns = columnsUnion;\n  model.rows = compactedRows;\n  return model;\n}\n\ntransformers['timeseries_to_rows'] = {\n  description: 'Time series to rows',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns = [{ text: 'Time', type: 'date' }, { text: 'Metric' }, { text: 'Value' }];\n\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        model.rows.push([dp[1], series.target, dp[0]]);\n      }\n    }\n  },\n};\n\ntransformers['timeseries_to_columns'] = {\n  description: 'Time series to columns',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({ text: 'Time', type: 'date' });\n\n    // group by time\n    const points = {};\n\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      model.columns.push({ text: series.target });\n\n      for (let y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const timeKey = dp[1].toString();\n\n        if (!points[timeKey]) {\n          points[timeKey] = { time: dp[1] };\n          points[timeKey][i] = dp[0];\n        } else {\n          points[timeKey][i] = dp[0];\n        }\n      }\n    }\n\n    for (const time in points) {\n      const point = points[time];\n      const values = [point.time];\n\n      for (let i = 0; i < data.length; i++) {\n        const value = point[i];\n        values.push(value);\n      }\n\n      model.rows.push(values);\n    }\n  },\n};\n\ntransformers['timeseries_aggregations'] = {\n  description: 'Time series aggregations',\n  getColumns: () => {\n    return [\n      { text: 'Avg', value: 'avg' },\n      { text: 'Min', value: 'min' },\n      { text: 'Max', value: 'max' },\n      { text: 'Total', value: 'total' },\n      { text: 'Current', value: 'current' },\n      { text: 'Count', value: 'count' },\n    ];\n  },\n  transform: (data, panel, model) => {\n    let i, y;\n    model.columns.push({ text: 'Metric' });\n\n    for (i = 0; i < panel.columns.length; i++) {\n      model.columns.push({ text: panel.columns[i].text });\n    }\n\n    for (i = 0; i < data.length; i++) {\n      const series = new TimeSeries({\n        datapoints: data[i].datapoints,\n        alias: data[i].target,\n      });\n\n      series.getFlotPairs('connected');\n      const cells = [series.alias];\n\n      for (y = 0; y < panel.columns.length; y++) {\n        cells.push(series.stats[panel.columns[y].value]);\n      }\n\n      model.rows.push(cells);\n    }\n  },\n};\n\ntransformers['annotations'] = {\n  description: 'Annotations',\n  getColumns: () => {\n    return [];\n  },\n  transform: (data, panel, model) => {\n    model.columns.push({ text: 'Time', type: 'date' });\n    model.columns.push({ text: 'Title' });\n    model.columns.push({ text: 'Text' });\n    model.columns.push({ text: 'Tags' });\n\n    if (!data || !data.annotations || data.annotations.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < data.annotations.length; i++) {\n      const evt = data.annotations[i];\n      model.rows.push([evt.time, evt.title, evt.text, evt.tags]);\n    }\n  },\n};\n\ntransformers['table'] = {\n  description: 'Table',\n  getColumns: data => {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Single query returns data columns as is\n    if (data.length === 1) {\n      return [...data[0].columns];\n    }\n\n    // Track column indexes: name -> index\n    const columnNames = {};\n\n    // Union of all columns\n    const columns = data.reduce((acc, series) => {\n      series.columns.forEach(col => {\n        const { text } = col;\n        if (columnNames[text] === undefined) {\n          columnNames[text] = acc.length;\n          acc.push(col);\n        }\n      });\n      return acc;\n    }, []);\n\n    return columns;\n  },\n  transform: (data, panel, model) => {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    const noTableIndex = _.findIndex(data, (d: any) => d.type !== 'table');\n    if (noTableIndex > -1) {\n      throw {\n        message: `Result of query #${String.fromCharCode(\n          65 + noTableIndex\n        )} is not in table format, try using another transform.`,\n      };\n    }\n\n    mergeTablesIntoModel(model, ...data);\n  },\n};\n\ntransformers['json'] = {\n  description: 'JSON Data',\n  getColumns: data => {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    const names: any = {};\n    for (let i = 0; i < data.length; i++) {\n      const series = data[i];\n      if (series.type !== 'docs') {\n        continue;\n      }\n\n      // only look at 100 docs\n      const maxDocs = Math.min(series.datapoints.length, 100);\n      for (let y = 0; y < maxDocs; y++) {\n        const doc = series.datapoints[y];\n        const flattened = flatten(doc, null);\n        for (const propName in flattened) {\n          names[propName] = true;\n        }\n      }\n    }\n\n    return _.map(names, (value, key) => {\n      return { text: key, value: key };\n    });\n  },\n  transform: (data, panel, model) => {\n    let i, y, z;\n\n    for (const column of panel.columns) {\n      const tableCol: any = { text: column.text };\n\n      // if filterable data then set columns to filterable\n      if (data.length > 0 && data[0].filterable) {\n        tableCol.filterable = true;\n      }\n\n      model.columns.push(tableCol);\n    }\n\n    if (model.columns.length === 0) {\n      model.columns.push({ text: 'JSON' });\n    }\n\n    for (i = 0; i < data.length; i++) {\n      const series = data[i];\n\n      for (y = 0; y < series.datapoints.length; y++) {\n        const dp = series.datapoints[y];\n        const values: any[] = [];\n\n        if (_.isObject(dp) && panel.columns.length > 0) {\n          const flattened = flatten(dp, null);\n          for (z = 0; z < panel.columns.length; z++) {\n            values.push(flattened[panel.columns[z].value]);\n          }\n        } else {\n          values.push(JSON.stringify(dp));\n        }\n\n        model.rows.push(values);\n      }\n    }\n  },\n};\n\nfunction transformDataToTable(data, panel) {\n  const model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  const transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw { message: 'Transformer ' + panel.transform + ' not found' };\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport { transformers, transformDataToTable };\n","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;"],"sourceRoot":""}